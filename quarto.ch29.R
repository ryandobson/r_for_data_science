### R for Data Science 
#Second Edition: Chapter 29, Quarto          

#Restart the console to start fresh! 
#ctrl + shift + F10 

library(tidyverse) 

#> Quarto provides a unified authoring framework for data science. 
#> 
#> Quarto files are designed to be used in Three Ways: 
#> 1. For communicating to decision makes, who want to focus on the conclusions,
#> not the code behind the analysis 
#> 2. For collaborating with other data scientists (including future you), who 
#> are interested in both your conclusions, and how ou reach them (i.e. the code)
#> 3. As an environment in which to do data science, as a modern-day lab notebook
#> where you can capture not only what you did, but also what you were thinking 
#> 
#> A Quarto file .qmd contains three important types of content: 
#> 1. An (optional) YAML header surrounded by ---s. 
#> 2. Chunks of R code surrounded by ```
#> 3. Text mixed with simple text formatting like # heading _italics_
#> 
#> 
#> When in the file you can render the output to be in the document or in the 
#> other panes in R. Really just a personal choice/whatever works best for what 
#> you are doing. 
#> 
#> You can render everything by clicking "Render"
#> or press ctrl + shift + k 
#> or programttically with quarto::quarto_render("diamond-sizes.qmd")
#> 
#> This will display the report in the viewer pane and create an HTML file. 
#> 
#> When you render the document Quarto sends the .qmd file to knitr, which executes
#> all of the code chunks and creates a new markdown (.md) document which includes
#> the code and the output. 
#> The markdown file generated by knitr is then processed by pandoc, which is 
#> responsible for creating the finished file. 
#> From pandoc you can create a wide range of output formats, such as word, pdf, 
#> and much more. 
#> 
#> Visual Editor ------ 
#> 
#> The visual editor in RStudio provides a WYSIWYM (what you see is what you mean)
#> interface for authoring quarto documents. 
#> Under the hood, prose in Quarto documents (.qmd) files is written in Markdown,
#> a lightweight set of conventions for formatting plain text files. 
#> Pandoc(a slightly extended version of Markdown that Quarto understands)
#> 
#> In the visual editor you can either use buttons on the menu bar to insert 
#> different things, or you can use the catch-all shortcut "/" to insert just 
#> about anything. 
#> 
#> The visual editor displays your content with formatting, under the hood, it 
#> saves your content in plain Markdown. You can switch back and forth between
#> the visual and source editors to view and edit your content using either tool
#> 

#> Source Editor -----
#> 
#> They have a list of formatting in the textbook. 
#> Can also access a handy reference sheet with Help > Markdown Quick Reference 
#> (they are similar to Evernote's formatting)
#> 

#> Code Chunks -----
#> 
#> To run code inside a Quarto document, you need to insert a chunk. 
#> Three ways to insert a chunk: 
#> 1. keyboard shortcut: ctrl + alt + I
#> 2. The "Insert" button on the editor toolbar 
#> 3. By manually typing the chunk delimiters ```{r} and ```

#> They recommend the keyboard shortcut 

#> To run the code in a chunk, use the keyboard shortcut of ctrl + shift + enter
#> 
#> Think of a chunk like a function. A chunk should be relatively self-contained,
#> and focused around a single task. 
#> 
#> Chunks can be given a label: 
```{r}
#| label: simple-addition

1 + 1
```
#> This has three advantages: 
#> 1. You can more easily navigate to specific chunks using the drop-down 
#> navigator in the bottom-left of the script editor 
#> 2. Graphics produced by the chunks will have useful names that make them 
#> easier to use elsewhere. 
#> You can setup networks of cached chunks to avoid re-performing expensive 
#> computations on every run
#> 
#> Chunk labels should be short and evocative and should not contain spaces. 
#> They recommend dashes "-" to separate words. 
#> 
#> A chunk labeled "setup" will be run automatically once before any other code
#> is run when in notebook mode. 
#> 
#> Each chunk label must be unique. 
#> 
#> Chunks can be customized with "options" 
#> Knitr provides almost 60 options that you can use to customize your code chunks. 
#> Here are the most important ones: 
#> 
#> eval: false - prevents code from being evaluated. (the code won't be run. This
#> is good for displaying example code, or for disabling a large block of code 
#> without commenting it all out)
#> 
#> include: false - runs the code, but doesn't show the code or results in the 
#> final document (Use this for setup code that you don't want cluttering up
#> your final report)
#> 
#> echo: false - prevents code, but not the results from appearing in the finished
#> file. Use this when writing reports aimed at people who don't want to see the 
#> underlying R code. 
#> 
#> message: false OR warning: false - prevents messages or warnings from appearing
#> in the finished file 
#> 
#> results: hide - hides printed output
#> fig-show: hide - hides plots 
#> error: true - causes the render to continue even if code returns an error. This
#> is rarely something you will want to include in your final report, but can 
#> be useful if you need to debug exactly what is going on in your .qmd document.
#> Also helpful for teaching purposes. 
#> 
#> Each of these chunk options get added to the header of the chunk, following
#> #| 
#> For example: 
#> 
```{r}
#| label: simple-multiplication
#| eval: false

2 * 2
```

#> Global Options 
#> 
#> As you work more with Knitr, you will discover that some of the default chunk
#> options don't fit your needs and you want to change them. 
#> 
#> You can change the default code chunk options by applying them in the document
#> YAML, under execute. 
#> For example: 
title: "My report"
execute:
  echo: false



#> Inline Code 
#> 
#> You can also embed R code directly into the text with: `r`
#> This can be very useful if you mention properties of your data in the text! 
#> 
#> For example: 
#> We have data about `r nrow(diamonds)` diamonds. 
#> Turns into: 
#> We have data about 5940 diamonds. 
#> 
#> When inserting numbers into text, format() is your friends. 
#> It allows you to set the number of digits so you don't print to a ridiculous 
#> degree of accuracy, and a big.mark to make numbers easier to read. 
#> You might combine these into a helper function: 
comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
#> [1] "3,452,345"
comma(.12358124331)
#> [1] "0.12"

#> Figures ------
#> 
#> Figures can be embedded (as a PNG or JPEG) or generated as a result of a code
#> chunk. 
#> 
#> To embed an image from an external file, you can use the insert menu in Rstudio
#> and select figure/image. 
#> If you include a code chunk to generate a figure, it will automatically be 
#> included in your document. 
#> 
#> 
#> Figure Sizing 
#> 
#> There are five main options that control figure sizing: 
#> fig-width, fig-height, fig-asp, out-width, and out-height
#> Image sizing is challenging because there are two sizes (the size of the figure
#> created by R and the size at which it is inserted in the output document), and
#> multiple ways of specifying the size (height, width, aspect ratio: pick two
#> of three) 
#> 
#> They recommend three of the five options: 
#> 
#> Plots tend to be more aesthetically pleasing if they have consistent width. 
#> To enforce this, set fig-width 6 (6") and fig-asp: 0.618 (the golden ratio)
#> in the defaults. Then in individual chunks, only adjust fig-asp. 
#> 
#> Control the output size with out-width and set it to a percentage of the line
#> width. We suggest line-width: "0%" and fig-aling: center. 
#> 
#> To put multiple plots in a single row, set the layout-ncol to 2 for two plots, 
#> 3 for three plots, etc. Depending on what you're trying to illustrate (show 
#> data or plot variations), you might also tweak fig-width. 
#> 
#> If you find that you have to squint to read text in your plot, you need to 
#> tweak fig-width. 
#> If fig-width is larger than the size the figure is rendered in the final doc,
#> the text will be too small; if fig-width is smaller, the text will be too big. 
#> You will have to experiment a bit to figure out the right ratio between 
#> fig-width and the eventual width in your document. 
#> 
#> If you want to make sure the font size is consistent across all your figures,
#> whenever you set out-width, you'll also need to adust fig-width to maintain
#> the same ratio with your default out-width. 
#> For example, if your default fig-width is 6 and out-width is .7, when you set
#> out-width: "50%" you'll need to set fig-width to 4.3 (6 * .5/.7)
#> 
#> Figure sizing is an iterative, sometimes painful process. 
#> See https://www.tidyverse.org/blog/2020/08/taking-control-of-plot-scaling/ for
#> more help 
#> 
#> 
#> Other Important Options 
#> 
#> When mingling code and text, you can set fig-show: hold - so that plots 
#> are shown after the code. This has the side-effect of forcing you to break up
#> large blocks of code with their explanations. 
#> To add a caption to the plot, use fig-cap. In Quarto this will change the figure
#> from inline to "floating" 
#> 
#> Tables -------
#> 
#> You can insert tables in two different ways: 
#> markdown tables that you create directly in your Quarto document (using the 
#> Insert Table menu) OR 
#> tables generated as a result of a code chunk 
#> 
#> By default, Quarto prints data frames and matrices as you'd see them in the 
#> console. 
#> 
#> If you prefer the data be displayed with additional formatting you can use the
#> knitr::kable() function. 
kintr::kable(mtcars[1:5, ], )


#> Caching -------
#> 
#> Normally, each render of a document starts from a completely clean slate. 
#> This is great for reproducibility, because it ensures that you've captured
#> everything important in code. 
#> However, this can be a pain when working with large computations that take a 
#> long time to load. 
#> The solution is cache: true 
#> You can enable the Knitr cache at the document level for caching the results
#> of all computations in a document using standard YAML options: 
---
  title: "My Document"
execute: 
  cache: true
---

#> You can also do it for specific chunks
  ```{r}
#| cache: true

# code for lengthy computation...
```

#> The caching system must be used with care, because by default it is based on 
#> the code only, not its dependencies. 
#> 
#> Troubleshooting --------
#> 
#> Troubleshooting in Quarto can be challenging because you are no longer in an 
#> interactive R environment 
#> 
#> One common error in documents is duplicated chunk labels, which are especially
#> pervasive if our workflow involves copying and pasting code chunks. Just change
#> your duplicated labels to fix this issue. 
#> 
#> If the errors are due to the R code in the document, the first thing you should
#> always try is to recreate the problem in an interactive session. 
#> Restart R, then "Run all chunks" 
#> If you are lucky, that will recreate the problem and you can figure out what 
#> is going wrong interactively. 
#> 
#> If that doesn't work, that means there must be something different between 
#> your interactive environment and the Quarto environment. You're going to need
#> to systematically explore the options. 
#> The most common difference is the working directory
#> Check to see if the error is the same in an interactive R session and the Quarto
#> session. Use error: true in the Quarto session to display the problems. 
#> Use print() and str() to check that settings are as you expected. 
#> 
#> YAML Header ------
#> 
#> YAML stands for "YAML ain't markup language", which is designed for representing
#> hierarchical data in a way that's easy for humans to read and write. 
#> Quarto uses it to control many details of the output. 
#> 
#> Self-contained 
#> 
#> HTML documents typically have a number of external dependencies (CSS/images/
#> javascript). By default Quarto places these dependencies in a _file folder in 
#> the same directory as your .qmd file. 
#> If you want to email the report to a colleqaue, you might prefer to have a single,
#> self-contained, HTML document that embeds all its dependencies (instead of 
#> putting it in an online published platform where all the dependencies can 
#> live just fine in the background) 
#> You can do this with the embed-resources option: 
format:
  html:
  embed-resources: true
#> The resulting file will be self-contained, such that it will need no external
#> files and no internet access to be dispalyed by a browser. 
#> 
#> Parameters 
#> 
#> Quarto documents can include one or more parameters whose values can be set
#> when you render the report. 
#> Parameters are useful when you want to re-render the same report with distinct
#> values for various key inputs. 
#> To declare one or more parameters, use the params field:
---
  output: html_document
params:
  my_class: "suv"
---
  
  ```{r}
#| label: setup
#| include: false

library(tidyverse)

class <- mpg |> filter(class == params$my_class)
```

# Fuel economy for `r params$my_class`s

```{r}
#| message: false

ggplot(class, aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

#> Bibliographies and Citations 
#> 
#> The most straightforward way to add citations is using the visual editor.
#> Go to insert > citation
#> 
#> Citations can be inserted from a variety of sources. 
#> I will most likely use my document bibliography (a .bib file in the directory)
#> 
#> When Quarto renders your file, it will build and append a bibliography to the 
#> end of your documnt. 
#> This will not contain a section heading and you will have to add one. 
#> 
#> Workflow ------
#> 
#> Earlier we discussed a basic workflow for capturing your R code where you
#> work interactively in the console, then capture what works in the script
#> editor. 
#> Quarto brings together the console and the script editor, blurring the lines 
#> between interactive exploration and long-term code capture. 
#> You can rapidly iterate within a chunk, editing and re-executing with ctrl +
#> shift + enter. When you're happy, you move on and start a new chunk.
#> 
#> Quarto is also important because it so tightly integrates prose and code.
#> It makes it a great analysis notebook because it lets you develop code and 
#> record your thoughts. 
#> An analysis notebook shares many of the same goals as a classic lab notebook 
#> in the physical sciences: 
#>  Records what you did and why you did it. You will eventually forget and this
#>  makes it easier to come back to! 
#>  Supports rigorous thinking. You are more likely to come up with a strong
#>  analysis if you record your thoughts as you go, and continue to reflect on 
#>  them. Also saves time when you eventually write up your analysis to share
#>  with others. 
#>  Helps others understand your work. It is rare that you will do data analysis 
#>  by yourself, and you'll often be working as part of a team. A lab notebook 
#>  helps you share not only what you've done, but why you did it with your colleagues
#>  or lab mates. 
#>  
#>Tips: 
#> Ensure that each notebook has a descriptive title, an evocative file name, and
#> a first paragraph that briefly describes the aim of the analysis. 
#> 
#> Use the YAML header date field to record the date you started working on the
#> notebook.Use YYYY-MM-DD format so there is no ambiguity. 
#> 
#> If you spend a lot time on an analysis idea and it turns out to be a dead end,
#> don't delete it! Write up a brief note about why it failed and leave it in the
#> notebook. That will help you avoid going down the same dead end when you come
#> back to the analysis int he future 
#> 
#> Generally, you're better off doing data entry outside of R. But if you do need
#> to record a small snippet of data, clearly lay it out using tibble::tribble().
#> 
#> If you discover an error in a data file, never modify it directly, but instead
#> write code to correct the value. Explain why you made the fix. 
#> 
#> Before you finish for the day, make sure you can render the notebook. If you're
#> using caching, make sure to clear the caches. That will let you fix any problems
#> while they are fresh in mind. 
#> 
#> If you want your code to be reproducible in the long-run (so you can come back
#> to it next month or next year), you'll need to track the versions of the packages
#> that your code uses. A rigorous approach is to use renv https://rstudio.github.io/renv/
#> which stores packages in your project directory. A quick and dirty hack is to 
#> include a chunk that runs sessionInfo() - that won't let you recreate your 
#> packages as they are today, but at least you know what they were. 
#> 
#> You are going to create many analyses notebooks over the years. Think about 
#> how to organize them. They recommend storing them in individual projects and
#> coming up with a good naming scheme. 
#> 
#> 




